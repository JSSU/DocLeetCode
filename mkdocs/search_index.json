{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n\n\n\nunordered_set(key, value);\ni++;", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.  unordered_set(key, value);\ni++;", 
            "title": "Project layout"
        }, 
        {
            "location": "/menu/", 
            "text": "Menu\n\n\nList of Content", 
            "title": "Menu"
        }, 
        {
            "location": "/menu/#menu", 
            "text": "", 
            "title": "Menu"
        }, 
        {
            "location": "/menu/#list-of-content", 
            "text": "", 
            "title": "List of Content"
        }, 
        {
            "location": "/about/", 
            "text": "Hoc vulneret\n\n\nCum superabat aurata\n\n\nLorem \nmarkdownum fleturi\n en Aetne poscitur ausam, sine, venatu. Caret versus\net tum sed tellus \noderat male fata\n plurima ubi ortus sororis verba, erit\nStyge lacerae, solitis. Ulixes aperta minanti, frangitur fortunata domum tibi\nlacertos Haemoniae.\n\n\nEquos repperit haerent via sic fratrisque ramos. Cacumina parem victor alumno et\ndum nec eadem percussis \nora quod ipsa\n patientia Sirinosque laetior comae.\n\n\nFestinus sua nam aberat parentque voluntas fuit\n\n\nNati pirithoi Mensis flammamque iam, ab quique scelerate recepi multae timendi\nloquendo illi; tergum exsiluere monstri. Succurrere \nubera fertur\nfacis\n cura; huic sibi aliter pyropo, poenam illa\ncentimanum ignaram uvae tui \nsecedit\n? Agantur sublimis ducem fata, serieque\ndiscordia hominum persequar, nec cum furcas malo auras et media dubitate.\nCereremque si huic nocens, \ntelo\n?\n\n\n\n\nVidet est est exitiabile actum equos\n\n\nVulgata ritu propter illas et summa et\n\n\nPrimum sustineant Aeoliique ait his est conspecta\n\n\nEadem iniuria tot fodientibus tum exitus tellus\n\n\n\n\nInviso inpulit\n\n\nGurgite adversas et terrae locorum membra? Tale quam membra causa, illa os\nprocul Ladonis, ex tendit amictu templo. Signa edere eris spemque vivit! Dextris\nin mandate excipit armentaque iamque tectoque undas animans, sub\n\nat\n quam\n\net\n numinis eadem uritur\nquam secuta \nvel\n.\n\n\n\n\nInpositaque quod\n\n\nEgo in\n\n\nIaculum senectus senectus ut actaque Pelia fulmine\n\n\nAb ferae dum parant pectus\n\n\nAd ausa\n\n\nOssibus Troezen Faunine\n\n\n\n\nQuem gravitate canes: luna circumdata paratur; \nnon\n una Nixosque se corde, quam\n\ndum\n, visam, centum. Nubes putes relicta \numeros tumidarum\ncolonus\n, tecta; cremabo, nec. \nDementia\nmediam\n, utroque ruere: huc lati, nec ait Pactolides Caesarea viscera voluptas\nvultus \nsucos\n! Tum quisquam gemitus parentali Dixit nos a aethere, insula,\ntrabibus indulgens, triplicis.\n\n\nDeserti irascentemque placuit ratione magno. Pronusque deos esse subiectis, qui\nne iuvenem terque echidnis et grave venitque nullos nova abnuat. Instantem\ncruorem in ora vertatur angues; ubi hoc naufragus rapuere, atque \nsolem\nsecuriferumque\n.", 
            "title": "About"
        }, 
        {
            "location": "/about/#hoc-vulneret", 
            "text": "", 
            "title": "Hoc vulneret"
        }, 
        {
            "location": "/about/#cum-superabat-aurata", 
            "text": "Lorem  markdownum fleturi  en Aetne poscitur ausam, sine, venatu. Caret versus\net tum sed tellus  oderat male fata  plurima ubi ortus sororis verba, erit\nStyge lacerae, solitis. Ulixes aperta minanti, frangitur fortunata domum tibi\nlacertos Haemoniae.  Equos repperit haerent via sic fratrisque ramos. Cacumina parem victor alumno et\ndum nec eadem percussis  ora quod ipsa  patientia Sirinosque laetior comae.", 
            "title": "Cum superabat aurata"
        }, 
        {
            "location": "/about/#festinus-sua-nam-aberat-parentque-voluntas-fuit", 
            "text": "Nati pirithoi Mensis flammamque iam, ab quique scelerate recepi multae timendi\nloquendo illi; tergum exsiluere monstri. Succurrere  ubera fertur\nfacis  cura; huic sibi aliter pyropo, poenam illa\ncentimanum ignaram uvae tui  secedit ? Agantur sublimis ducem fata, serieque\ndiscordia hominum persequar, nec cum furcas malo auras et media dubitate.\nCereremque si huic nocens,  telo ?   Videt est est exitiabile actum equos  Vulgata ritu propter illas et summa et  Primum sustineant Aeoliique ait his est conspecta  Eadem iniuria tot fodientibus tum exitus tellus", 
            "title": "Festinus sua nam aberat parentque voluntas fuit"
        }, 
        {
            "location": "/about/#inviso-inpulit", 
            "text": "Gurgite adversas et terrae locorum membra? Tale quam membra causa, illa os\nprocul Ladonis, ex tendit amictu templo. Signa edere eris spemque vivit! Dextris\nin mandate excipit armentaque iamque tectoque undas animans, sub at  quam et  numinis eadem uritur\nquam secuta  vel .   Inpositaque quod  Ego in  Iaculum senectus senectus ut actaque Pelia fulmine  Ab ferae dum parant pectus  Ad ausa  Ossibus Troezen Faunine   Quem gravitate canes: luna circumdata paratur;  non  una Nixosque se corde, quam dum , visam, centum. Nubes putes relicta  umeros tumidarum\ncolonus , tecta; cremabo, nec.  Dementia\nmediam , utroque ruere: huc lati, nec ait Pactolides Caesarea viscera voluptas\nvultus  sucos ! Tum quisquam gemitus parentali Dixit nos a aethere, insula,\ntrabibus indulgens, triplicis.  Deserti irascentemque placuit ratione magno. Pronusque deos esse subiectis, qui\nne iuvenem terque echidnis et grave venitque nullos nova abnuat. Instantem\ncruorem in ora vertatur angues; ubi hoc naufragus rapuere, atque  solem\nsecuriferumque .", 
            "title": "Inviso inpulit"
        }, 
        {
            "location": "/usefullinks/", 
            "text": "\u6709\u7528\u7684\u94fe\u63a5\n\n\n\u81ea\u5df1\u7684\n\n\nBlog\n\n\nLeetCode Documentation\n \n\n\n\u6d59\u6c5f\u5927\u5b66\u8d44\u6599", 
            "title": "Links"
        }, 
        {
            "location": "/usefullinks/#_1", 
            "text": "", 
            "title": "\u6709\u7528\u7684\u94fe\u63a5"
        }, 
        {
            "location": "/usefullinks/#_2", 
            "text": "Blog  LeetCode Documentation    \u6d59\u6c5f\u5927\u5b66\u8d44\u6599", 
            "title": "\u81ea\u5df1\u7684"
        }, 
        {
            "location": "/Reference/functionDetails/", 
            "text": "\ufeff# Function or predefine items\n\n\nAccess Specifiers\n\n\npublic\n members can be accessed from outside the class.\n\n\nprotected\n members can be accessed in the class and its derived classes \n\n\nprivate\n members can be only accessed within the class. \n\n\n\n\nNote that the member being \nstatic\n or not the same Access Specification rules\napply to it.\n\nstatic\n implies the storage specification and that the some member will be shared \nacross all the instances of the class it does not change where the member can be \naccessed.\n\n\n\n\nHeap\n\n\nmake_heap()\n\n\n// range heap example\n#include \niostream\n     // std::cout\n#include \nalgorithm\n    // std::make_heap, std::pop_heap, std::push_heap, std::sort_heap\n#include \nvector\n       // std::vector\n\nusing namespace std;\nint main () {\n  //int myints[] = {10,20,30,5,15};\n  //std::vector\nint\n v(myints,myints+5);\n\n  vector\nint\n v{10,20,30,5,15};\n  std::make_heap (v.begin(),v.end());\n  std::cout \n \ninitial max heap   : \n \n v.front() \n '\\n';\n  std::cout \n \nv range :\n;\n  for (unsigned i=0; i\nv.size(); i++)\n    std::cout \n ' ' \n v[i];   std::cout \n '\\n';\n\n  std::pop_heap (v.begin(),v.end()); v.pop_back();\n  std::cout \n \nmax heap after pop : \n \n v.front() \n '\\n';\n    std::cout \n \nv range :\n;\n  for (unsigned i=0; i\nv.size(); i++)\n    std::cout \n ' ' \n v[i];   std::cout \n '\\n';\n//---------------------------------------------\n  v.pop_back(); std::pop_heap (v.begin(),v.end()); \n  std::cout \n \nmax heap after pop : \n \n v.front() \n '\\n';\n    std::cout \n \nv :\n;\n  for (unsigned i=0; i\nv.size(); i++)\n    std::cout \n ' ' \n v[i];   std::cout \n '\\n';\n\n\n\n  v.push_back(99); std::push_heap (v.begin(),v.end());\n  std::cout \n \nmax heap after push: \n \n v.front() \n '\\n';\n  std::cout \n \nfinal sorted range :\n;\n  for (unsigned i=0; i\nv.size(); i++)\n    std::cout \n ' ' \n v[i];   std::cout \n '\\n';\n\n  std::sort_heap (v.begin(),v.end());\n //make_heap(v.begin(),v.end());\n  std::cout \n \nfinal sorted range :\n;\n  for (unsigned i=0; i\nv.size(); i++)\n    std::cout \n ' ' \n v[i];\n\n  std::cout \n '\\n';\n\n  return 0;\n}\n\n\n\n\nresult\n\n\ninitial max heap   : 30\nv range : 30 20 10 5 15\nmax heap after pop : 20\nv range : 20 15 10 5\nmax heap after pop : 15\nv : 15 10 20\nmax heap after push: 99\nfinal sorted range : 99 15 20 10\nfinal sorted range : 10 15 20 99\n\n\n\nLambda functions\n\n\nConstructs a closure: an unnamed function object capable of capturing variables in scope.\nSyntax\n\n\n[ \ncapture-list\n ] ( \nparams\n ) mutable(optional) constexpr(optional)(c++17) exception attribute -\n ret { body }  (1)\n\n[ \ncapture-list\n ] ( \nparams\n ) -\n ret { \nbody\n } (2) \n\n[ \ncapture-list\n ] ( \nparams\n ) { \nbody\n }  (3) \n\n[ \ncapture-list\n ] { \nbody\n } (4) \n\n1) Full declaration.\n2) Declaration of a const lambda: the objects captured by copy cannot be modified.\n3) Omitted trailing-return-type: the return type of the closure's operator() is determined according to the following rules:\n\n\n\n\nif the body consists of nothing but a single return statement with an expression, \nthe return type is the type of the returned expression \n(after lvalue-to-rvalue, array-to-pointer, or function-to-pointer \nimplicit conversion);\n\n\notherwise, the return type is void.\n(until C++14)  \n\n\nThe return type is deduced from return statements as if for a \nfunction whose return type is declared auto.\n4) Omitted parameter list: function takes no arguments, as if the parameter list was ().\n\n\n\n\nExplanation\n\n\nmutable\n   -   allows body to modify the parameters captured by copy, and to call their non-const member functions\n\n\nconstexpr(C++17)\n  -   explicitly specifies that the function call operator is a constexpr function. When this specifier is not present, the function call operator will be constexpr anyway, if it happens to satisfy all constexpr function requirements\n\n\nexception\n -   provides the exception specification or the noexcept clause for operator() of the closure type\n\n\nattribute\n -   provides the attribute specification for operator() of the closure type\n\n\ncapture-list\n  -   a comma-separated list of zero or more captures, optionally beginning with a capture-default.\n\nCapture list can be passed as follows (see below for the detailed description):  \n\n+ \n[a,\nb]\n where a is captured by value and b is captured by reference.\n\n+ \n[this]\n captures the this pointer by value\n+ \n[\n]\n captures all automatic variables odr-used in the body of the lambda by reference\n+ \n[=]\n captures all automatic variables odr-used in the body of the lambda by value\n+ \n[]\n captures nothing\n\n\nparams\n    -   The list of parameters, as in named functions, except that default arguments are not allowed (until C++14). If auto is used as a type of a parameter, the lambda is a generic lambda. (since C++14)\n\n\nret\n   -   Return type. If not present it's implied by the function return statements (or void if it doesn't return any value)\n\n\nbody\n  -   Function body\nThe lambda expression is a prvalue expression whose value is \n\n(until C++17)\nwhose result object is \n(since C++17)\n an unnamed\n temporary object of unique unnamed non-union non-aggregate class\n type, known as closure type, which is declared (for the purposes \n of ADL) in the smallest block scope, class scope, or namespace \n scope that contains the lambda expression. The closure type has \n the following members:", 
            "title": "Reference"
        }, 
        {
            "location": "/Reference/functionDetails/#access-specifiers", 
            "text": "public  members can be accessed from outside the class.  protected  members can be accessed in the class and its derived classes   private  members can be only accessed within the class.    Note that the member being  static  or not the same Access Specification rules\napply to it. static  implies the storage specification and that the some member will be shared \nacross all the instances of the class it does not change where the member can be \naccessed.", 
            "title": "Access Specifiers"
        }, 
        {
            "location": "/Reference/functionDetails/#heap", 
            "text": "", 
            "title": "Heap"
        }, 
        {
            "location": "/Reference/functionDetails/#make_heap", 
            "text": "// range heap example\n#include  iostream      // std::cout\n#include  algorithm     // std::make_heap, std::pop_heap, std::push_heap, std::sort_heap\n#include  vector        // std::vector\n\nusing namespace std;\nint main () {\n  //int myints[] = {10,20,30,5,15};\n  //std::vector int  v(myints,myints+5);\n\n  vector int  v{10,20,30,5,15};\n  std::make_heap (v.begin(),v.end());\n  std::cout    initial max heap   :     v.front()   '\\n';\n  std::cout    v range : ;\n  for (unsigned i=0; i v.size(); i++)\n    std::cout   ' '   v[i];   std::cout   '\\n';\n\n  std::pop_heap (v.begin(),v.end()); v.pop_back();\n  std::cout    max heap after pop :     v.front()   '\\n';\n    std::cout    v range : ;\n  for (unsigned i=0; i v.size(); i++)\n    std::cout   ' '   v[i];   std::cout   '\\n';\n//---------------------------------------------\n  v.pop_back(); std::pop_heap (v.begin(),v.end()); \n  std::cout    max heap after pop :     v.front()   '\\n';\n    std::cout    v : ;\n  for (unsigned i=0; i v.size(); i++)\n    std::cout   ' '   v[i];   std::cout   '\\n';\n\n\n\n  v.push_back(99); std::push_heap (v.begin(),v.end());\n  std::cout    max heap after push:     v.front()   '\\n';\n  std::cout    final sorted range : ;\n  for (unsigned i=0; i v.size(); i++)\n    std::cout   ' '   v[i];   std::cout   '\\n';\n\n  std::sort_heap (v.begin(),v.end());\n //make_heap(v.begin(),v.end());\n  std::cout    final sorted range : ;\n  for (unsigned i=0; i v.size(); i++)\n    std::cout   ' '   v[i];\n\n  std::cout   '\\n';\n\n  return 0;\n}", 
            "title": "make_heap()"
        }, 
        {
            "location": "/Reference/functionDetails/#result", 
            "text": "initial max heap   : 30\nv range : 30 20 10 5 15\nmax heap after pop : 20\nv range : 20 15 10 5\nmax heap after pop : 15\nv : 15 10 20\nmax heap after push: 99\nfinal sorted range : 99 15 20 10\nfinal sorted range : 10 15 20 99", 
            "title": "result"
        }, 
        {
            "location": "/Reference/functionDetails/#lambda-functions", 
            "text": "Constructs a closure: an unnamed function object capable of capturing variables in scope.\nSyntax  [  capture-list  ] (  params  ) mutable(optional) constexpr(optional)(c++17) exception attribute -  ret { body }  (1) \n[  capture-list  ] (  params  ) -  ret {  body  } (2)  \n[  capture-list  ] (  params  ) {  body  }  (3)  \n[  capture-list  ] {  body  } (4)  \n1) Full declaration.\n2) Declaration of a const lambda: the objects captured by copy cannot be modified.\n3) Omitted trailing-return-type: the return type of the closure's operator() is determined according to the following rules:   if the body consists of nothing but a single return statement with an expression, \nthe return type is the type of the returned expression \n(after lvalue-to-rvalue, array-to-pointer, or function-to-pointer \nimplicit conversion);  otherwise, the return type is void.\n(until C++14)    The return type is deduced from return statements as if for a \nfunction whose return type is declared auto.\n4) Omitted parameter list: function takes no arguments, as if the parameter list was ().   Explanation  mutable    -   allows body to modify the parameters captured by copy, and to call their non-const member functions  constexpr(C++17)   -   explicitly specifies that the function call operator is a constexpr function. When this specifier is not present, the function call operator will be constexpr anyway, if it happens to satisfy all constexpr function requirements  exception  -   provides the exception specification or the noexcept clause for operator() of the closure type  attribute  -   provides the attribute specification for operator() of the closure type  capture-list   -   a comma-separated list of zero or more captures, optionally beginning with a capture-default. \nCapture list can be passed as follows (see below for the detailed description):   \n+  [a, b]  where a is captured by value and b is captured by reference. \n+  [this]  captures the this pointer by value\n+  [ ]  captures all automatic variables odr-used in the body of the lambda by reference\n+  [=]  captures all automatic variables odr-used in the body of the lambda by value\n+  []  captures nothing  params     -   The list of parameters, as in named functions, except that default arguments are not allowed (until C++14). If auto is used as a type of a parameter, the lambda is a generic lambda. (since C++14)  ret    -   Return type. If not present it's implied by the function return statements (or void if it doesn't return any value)  body   -   Function body\nThe lambda expression is a prvalue expression whose value is  (until C++17) whose result object is  (since C++17)  an unnamed\n temporary object of unique unnamed non-union non-aggregate class\n type, known as closure type, which is declared (for the purposes \n of ADL) in the smallest block scope, class scope, or namespace \n scope that contains the lambda expression. The closure type has \n the following members:", 
            "title": "Lambda functions"
        }, 
        {
            "location": "/Reference/One VS another/", 
            "text": "\ufeff# One VS Another\nSome common comparism between one feature to another.\n\n\npush_back vs emplace_back\n\n\nIn addition to what visitor said :\n\n\nThe function void \nemplace_back(Type\n _Val\n provided by MSCV10 is \nnon conforming and redundant, because as you noted it is strictly equivalent\nto \npush_back(Type\n _Val)\n.\n\n\nBut the real C++0x form of \nemplace_back\n is really useful: \nvoid emplace_back(Args\n...)\n;\n\n\nInstead of taking a \nvalue_type\n it takes a variadic list of arguments, \nso that means that you can now perfectly forward the argument and construct \ndirectly an object into a container without temporary at all. \n\n\nThat's useful, Because no matter how much cleverness RVO and move semantic bring to the \ntable there is still complicated cases where a push_back is likely to make unnecessary \ncopies (or move). For example, with the traditional \ninsert()\n function of a \nstd::map\n, \nyou have to create a temporary, which will then be copied into a \nstd::pair\nKey, Value\n, \nwhich will then be copied into the map : \n\n\nstd::map\nint, Complicated\n m;\nint anInt = 4;\ndouble aDouble = 5.0;\nstd::string aString = \nC++\n;\n\n// cross your finger so that the optimizer is really good\nm.insert(std::make_pair(4, Complicated(anInt, aDouble, aString))); \n\n// should be easier for the optimizer\nm.emplace(4, anInt, aDouble, aString);\n\n\n\n\nSo why didn't they implement the right version of emplace_back in MSVC ? \nActually it bugged me too a while ago, so I asked the same question on the \n\nVisual C++ blog\n.\nHere is the answer from Stephan T Lavavej, the official \nmaintainer of the Visual C++ standard library implementation at Microsoft.\n\n\n\n\nQ : Are beta 2 emplace functions just some kind of placeholder right now ?\n\n\nA : As you may know, variadic templates aren't implemented in VC10. We \n them with preprocessor machinery for things like \nmake_shared\nT\n()\n, \ntuple, and the new things in \nfunctional\n. This preprocessor machinery is \nrelatively difficult to use and maintain. Also, it significantly affects \ncompilation speed, as we have to repeatedly include subheaders. Due to a \ncombination of our time constraints and compilation speed concerns, \nwe haven't simulated variadic templates in our emplace functions.\n\n\nWhen variadic templates are implemented in the compiler, you can expect \nthat we'll take advantage of them in the libraries, including in our \nemplace functions. We take conformance very seriously, but unfortunately \nwe can't do everything all at once.\n\n\n\n\nIt's an understandable decision. Everyone who tried just once to emulate \nvariadic template with preprocessor horrible tricks know how disgusting \nthis stuff gets. \n\n\n#include \niostream\n\n#include \nvector\n\n#include \nctime\n\n#include \nratio\n\n#include \nchrono\n\n\nusing namespace std;\nusing namespace std::chrono;\n\nint main() {\n\n  vector\nint\n v1;\n  const size_t N = 100000000;\n\n  high_resolution_clock::time_point t1 = high_resolution_clock::now();\n  for(size_t i = 0; i \n N; ++i)\n    v1.push_back(i);\n  high_resolution_clock::time_point t2 = high_resolution_clock::now();\n\n  duration\ndouble\n time_span = duration_cast\nduration\ndouble\n(t2 - t1);\n\n  std::cout \n \npush_back took me \n \n time_span.count() \n \n seconds.\n;\n  std::cout \n std::endl;\n\n  vector\nint\n v2;\n\n  t1 = high_resolution_clock::now();\n  for(size_t i = 0; i \n N; ++i)\n    v2.emplace_back(i);\n  t2 = high_resolution_clock::now();\n  time_span = duration_cast\nduration\ndouble\n(t2 - t1);\n  std::cout \n \nemplace_back took me \n \n time_span.count() \n \n seconds.\n;\n  std::cout \n std::endl;\n\n  return 0;\n}", 
            "title": "Compare"
        }, 
        {
            "location": "/Reference/One VS another/#push_back-vs-emplace_back", 
            "text": "In addition to what visitor said :  The function void  emplace_back(Type  _Val  provided by MSCV10 is \nnon conforming and redundant, because as you noted it is strictly equivalent\nto  push_back(Type  _Val) .  But the real C++0x form of  emplace_back  is really useful:  void emplace_back(Args ...) ;  Instead of taking a  value_type  it takes a variadic list of arguments, \nso that means that you can now perfectly forward the argument and construct \ndirectly an object into a container without temporary at all.   That's useful, Because no matter how much cleverness RVO and move semantic bring to the \ntable there is still complicated cases where a push_back is likely to make unnecessary \ncopies (or move). For example, with the traditional  insert()  function of a  std::map , \nyou have to create a temporary, which will then be copied into a  std::pair Key, Value , \nwhich will then be copied into the map :   std::map int, Complicated  m;\nint anInt = 4;\ndouble aDouble = 5.0;\nstd::string aString =  C++ ;\n\n// cross your finger so that the optimizer is really good\nm.insert(std::make_pair(4, Complicated(anInt, aDouble, aString))); \n\n// should be easier for the optimizer\nm.emplace(4, anInt, aDouble, aString);  So why didn't they implement the right version of emplace_back in MSVC ? \nActually it bugged me too a while ago, so I asked the same question on the  Visual C++ blog .\nHere is the answer from Stephan T Lavavej, the official \nmaintainer of the Visual C++ standard library implementation at Microsoft.   Q : Are beta 2 emplace functions just some kind of placeholder right now ?  A : As you may know, variadic templates aren't implemented in VC10. We \n them with preprocessor machinery for things like  make_shared T () , \ntuple, and the new things in  functional . This preprocessor machinery is \nrelatively difficult to use and maintain. Also, it significantly affects \ncompilation speed, as we have to repeatedly include subheaders. Due to a \ncombination of our time constraints and compilation speed concerns, \nwe haven't simulated variadic templates in our emplace functions.  When variadic templates are implemented in the compiler, you can expect \nthat we'll take advantage of them in the libraries, including in our \nemplace functions. We take conformance very seriously, but unfortunately \nwe can't do everything all at once.   It's an understandable decision. Everyone who tried just once to emulate \nvariadic template with preprocessor horrible tricks know how disgusting \nthis stuff gets.   #include  iostream \n#include  vector \n#include  ctime \n#include  ratio \n#include  chrono \n\nusing namespace std;\nusing namespace std::chrono;\n\nint main() {\n\n  vector int  v1;\n  const size_t N = 100000000;\n\n  high_resolution_clock::time_point t1 = high_resolution_clock::now();\n  for(size_t i = 0; i   N; ++i)\n    v1.push_back(i);\n  high_resolution_clock::time_point t2 = high_resolution_clock::now();\n\n  duration double  time_span = duration_cast duration double (t2 - t1);\n\n  std::cout    push_back took me     time_span.count()     seconds. ;\n  std::cout   std::endl;\n\n  vector int  v2;\n\n  t1 = high_resolution_clock::now();\n  for(size_t i = 0; i   N; ++i)\n    v2.emplace_back(i);\n  t2 = high_resolution_clock::now();\n  time_span = duration_cast duration double (t2 - t1);\n  std::cout    emplace_back took me     time_span.count()     seconds. ;\n  std::cout   std::endl;\n\n  return 0;\n}", 
            "title": "push_back vs emplace_back"
        }, 
        {
            "location": "/templateLeetCode/", 
            "text": "This is a Template Pages\n\n\nLeetCode #3\n\n\nHere is the content", 
            "title": "ZTemplatePage"
        }, 
        {
            "location": "/templateLeetCode/#this-is-a-template-pages", 
            "text": "LeetCode #3  Here is the content", 
            "title": "This is a Template Pages"
        }, 
        {
            "location": "/Leetcode/355 Design Twitter/", 
            "text": "\ufeff# 355\n\n\nDesign Twitter\n\n\nDesign a simplified version of Twitter where users can post tweets,\nfollow/unfollow another user and is able to see the 10 most recent\ntweets in the user's news feed. Your design should support the \nfollowing methods:\n\n\n\n\npostTweet(userId, tweetId)\n: Compose a new tweet.\n\n\ngetNewsFeed(userId)\n: Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n\n\nfollow(followerId, followeeId)\n: Follower follows a followee.\n\n\nunfollow(followerId, followeeId)\n: Follower unfollows a followee.\n\n\n\n\nExample\n:\n\n\nTwitter twitter = new Twitter();\n\n// User 1 posts a new tweet (id = 5).\ntwitter.postTweet(1, 5);\n\n// User 1's news feed should return a list with 1 tweet id -\n [5].\ntwitter.getNewsFeed(1);\n\n// User 1 follows user 2.\ntwitter.follow(1, 2);\n\n// User 2 posts a new tweet (id = 6).\ntwitter.postTweet(2, 6);\n\n// User 1's news feed should return a list with 2 tweet ids -\n [6, 5].\n// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.getNewsFeed(1);\n\n// User 1 unfollows user 2.\ntwitter.unfollow(1, 2);\n\n// User 1's news feed should return a list with 1 tweet id -\n [5],\n// since user 1 is no longer following user 2.\ntwitter.getNewsFeed(1);\n\n\n\n\nTags\n: Hash Table Heap Design\n\n\nSolution\n\n\nclass Twitter\n{\n    struct Tweet\n    {\n        int time;\n        int id;\n        Tweet(int t, int i)\n        {\n            time = t;\n            id = i;\n        }\n        //Tweet(int time, int id) : time(time), id(id) {}\n    };\n\n    unordered_map\nint, vector\nTweet\n tweets; // [u] = array of tweets by u\n    unordered_map\nint, unordered_set\nint\n following; // [u] = array of users followed by u\n\n    int time;\n\npublic:\n    Twitter() : time(0) {}\n\n    void postTweet(int userId, int tweetId)\n    {\n        tweets[userId].emplace_back(time++, tweetId);\n    }\n\n    vector\nint\n getNewsFeed(int userId)\n    {\n        vector\npair\nTweet*, Tweet*\n h; // pair of pointers (begin, current)\n\n        for (auto\n u: following[userId])\n        {\n            auto\n t = tweets[u];\n            if (t.size() \n 0)\n                h.emplace_back(t.data(), t.data() + t.size() - 1);\n        }\n        auto\n t = tweets[userId]; // self\n        if (t.size() \n 0)\n            h.emplace_back(t.data(), t.data() + t.size() - 1);\n\n        auto f = [](const pair\nTweet*, Tweet*\n x, const pair\nTweet*, Tweet*\n y) {\n            return x.second-\ntime \n y.second-\ntime;\n        };\n        make_heap(h.begin(), h.end(), f);\n\n        const int n = 10;\n        vector\nint\n o;\n        o.reserve(n);\n        for (int i = 0; (i \n n) \n !h.empty(); ++i)\n        {\n            pop_heap(h.begin(), h.end(), f);\n\n            auto\n hb = h.back();\n            o.push_back(hb.second-\nid);\n\n            if (hb.first == hb.second--)\n                h.pop_back();\n            else\n                push_heap(h.begin(), h.end(), f);\n        }\n        return o;\n    }\n\n    void follow(int followerId, int followeeId)\n    {\n        if (followerId != followeeId)\n            following[followerId].insert(followeeId);\n    }\n\n    void unfollow(int followerId, int followeeId)\n    {\n        following[followerId].erase(followeeId);\n    }\n};\n\n\n\n\nGiven template\n\n\nclass Twitter {\npublic:\n    /** Initialize your data structure here. */\n    Twitter() {\n\n    }\n\n    /** Compose a new tweet. */\n    void postTweet(int userId, int tweetId) {\n\n    }\n\n    /** Retrieve the 10 most recent tweet ids in the user's\n     news feed. Each item in the news feed must be posted by \n     users who the user followed or by the user herself. \n     Tweets must be ordered from most recent to least recent. */\n    vector\nint\n getNewsFeed(int userId) {\n\n    }\n\n    /** Follower follows a followee. If the operation is invalid, \n    it should be a no-op. */\n    void follow(int followerId, int followeeId) {\n\n    }\n\n    /** Follower unfollows a followee. If the operation is invalid, \n    it should be a no-op. */\n    void unfollow(int followerId, int followeeId) {\n\n    }\n};\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter obj = new Twitter();\n * obj.postTweet(userId,tweetId);\n * vector\nint\n param_2 = obj.getNewsFeed(userId);\n * obj.follow(followerId,followeeId);\n * obj.unfollow(followerId,followeeId);\n */\n\n\n\n\nSum", 
            "title": "355. Design Twitter"
        }, 
        {
            "location": "/Leetcode/355 Design Twitter/#design-twitter", 
            "text": "Design a simplified version of Twitter where users can post tweets,\nfollow/unfollow another user and is able to see the 10 most recent\ntweets in the user's news feed. Your design should support the \nfollowing methods:   postTweet(userId, tweetId) : Compose a new tweet.  getNewsFeed(userId) : Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.  follow(followerId, followeeId) : Follower follows a followee.  unfollow(followerId, followeeId) : Follower unfollows a followee.   Example :  Twitter twitter = new Twitter();\n\n// User 1 posts a new tweet (id = 5).\ntwitter.postTweet(1, 5);\n\n// User 1's news feed should return a list with 1 tweet id -  [5].\ntwitter.getNewsFeed(1);\n\n// User 1 follows user 2.\ntwitter.follow(1, 2);\n\n// User 2 posts a new tweet (id = 6).\ntwitter.postTweet(2, 6);\n\n// User 1's news feed should return a list with 2 tweet ids -  [6, 5].\n// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.getNewsFeed(1);\n\n// User 1 unfollows user 2.\ntwitter.unfollow(1, 2);\n\n// User 1's news feed should return a list with 1 tweet id -  [5],\n// since user 1 is no longer following user 2.\ntwitter.getNewsFeed(1);  Tags : Hash Table Heap Design", 
            "title": "Design Twitter"
        }, 
        {
            "location": "/Leetcode/355 Design Twitter/#solution", 
            "text": "class Twitter\n{\n    struct Tweet\n    {\n        int time;\n        int id;\n        Tweet(int t, int i)\n        {\n            time = t;\n            id = i;\n        }\n        //Tweet(int time, int id) : time(time), id(id) {}\n    };\n\n    unordered_map int, vector Tweet  tweets; // [u] = array of tweets by u\n    unordered_map int, unordered_set int  following; // [u] = array of users followed by u\n\n    int time;\n\npublic:\n    Twitter() : time(0) {}\n\n    void postTweet(int userId, int tweetId)\n    {\n        tweets[userId].emplace_back(time++, tweetId);\n    }\n\n    vector int  getNewsFeed(int userId)\n    {\n        vector pair Tweet*, Tweet*  h; // pair of pointers (begin, current)\n\n        for (auto  u: following[userId])\n        {\n            auto  t = tweets[u];\n            if (t.size()   0)\n                h.emplace_back(t.data(), t.data() + t.size() - 1);\n        }\n        auto  t = tweets[userId]; // self\n        if (t.size()   0)\n            h.emplace_back(t.data(), t.data() + t.size() - 1);\n\n        auto f = [](const pair Tweet*, Tweet*  x, const pair Tweet*, Tweet*  y) {\n            return x.second- time   y.second- time;\n        };\n        make_heap(h.begin(), h.end(), f);\n\n        const int n = 10;\n        vector int  o;\n        o.reserve(n);\n        for (int i = 0; (i   n)   !h.empty(); ++i)\n        {\n            pop_heap(h.begin(), h.end(), f);\n\n            auto  hb = h.back();\n            o.push_back(hb.second- id);\n\n            if (hb.first == hb.second--)\n                h.pop_back();\n            else\n                push_heap(h.begin(), h.end(), f);\n        }\n        return o;\n    }\n\n    void follow(int followerId, int followeeId)\n    {\n        if (followerId != followeeId)\n            following[followerId].insert(followeeId);\n    }\n\n    void unfollow(int followerId, int followeeId)\n    {\n        following[followerId].erase(followeeId);\n    }\n};", 
            "title": "Solution"
        }, 
        {
            "location": "/Leetcode/355 Design Twitter/#given-template", 
            "text": "class Twitter {\npublic:\n    /** Initialize your data structure here. */\n    Twitter() {\n\n    }\n\n    /** Compose a new tweet. */\n    void postTweet(int userId, int tweetId) {\n\n    }\n\n    /** Retrieve the 10 most recent tweet ids in the user's\n     news feed. Each item in the news feed must be posted by \n     users who the user followed or by the user herself. \n     Tweets must be ordered from most recent to least recent. */\n    vector int  getNewsFeed(int userId) {\n\n    }\n\n    /** Follower follows a followee. If the operation is invalid, \n    it should be a no-op. */\n    void follow(int followerId, int followeeId) {\n\n    }\n\n    /** Follower unfollows a followee. If the operation is invalid, \n    it should be a no-op. */\n    void unfollow(int followerId, int followeeId) {\n\n    }\n};\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter obj = new Twitter();\n * obj.postTweet(userId,tweetId);\n * vector int  param_2 = obj.getNewsFeed(userId);\n * obj.follow(followerId,followeeId);\n * obj.unfollow(followerId,followeeId);\n */", 
            "title": "Given template"
        }, 
        {
            "location": "/Leetcode/355 Design Twitter/#sum", 
            "text": "", 
            "title": "Sum"
        }
    ]
}